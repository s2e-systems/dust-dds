//! The traits necessary to make a type capable of being published and subscribed by the DDS middleware.
//!
//! To be able to publish and subscribe the information contained in a type using DustDDS,
//! this type has to implement the following traits [`DdsHasKey`], [`CdrSerialize`], [`DdsDeserialize`],
//! [`DdsSerializeKeyFields`], [`DdsGetKeyFromFoo`], [`DdsGetKeyFromSerializedData`] and
//! [`DdsGetKeyFromSerializedKeyFields`]. Depending on the used functionality only a subset
//! of these traits might need to be implemented.
//!
//! While implementing the traits above is the most flexible way to have a type supported by
//! DustDDS it is the most common use case that a type must be transmitted using the format
//! defined by RTPS to ensure interoperability between different implementations.
//! For this common scenario DustDDS provides a set of traits which are simpler to implement
//! and which provide blanket implementations for the traits above. These are [`DdsRepresentation`],
//! [`DdsBorrowKeyHolder`] and [`DdsOwningKeyHolder`] in combination with
//! [`serde::Serialize`] and [`serde::Deserialize`].
//!
//! For the large majority of cases the simpler subset of traits can be automatically derived
//! using the provided procedural macro [`DdsType`]. Each of these traits can also be individually
//! derived using the respective proc macro.
//!

use std::io::{Read, Write};

use crate::{
    implementation::parameter_list_serde::{
        serde_parameter_list_deserializer::ParameterListDeserializer,
        serde_parameter_list_serializer::ParameterListSerializer,
    },
    infrastructure::error::{DdsError::PreconditionNotMet, DdsResult},
};

pub use dust_dds_derive::{
    DdsBorrowKeyHolder, DdsHasKey, DdsOwningKeyHolder, DdsRepresentation, CdrSerialize, DdsType,
};

/// The [`DdsSerializedData`] represents the serialized data of a type that can be
/// published and subscribed over DDS.
#[derive(
    Debug,
    PartialEq,
    Clone,
    Eq,
    derive_more::Constructor,
    derive_more::From,
    derive_more::Into,
    derive_more::AsRef,
)]
pub struct DdsSerializedData(Vec<u8>);

/// The [`DdsSerializedKey`] represents the key associated with a specific instance of
/// a type that can be published and subscribed over DDS.
#[derive(
    Debug,
    PartialEq,
    Clone,
    Eq,
    derive_more::Constructor,
    derive_more::From,
    derive_more::Into,
    derive_more::AsRef,
)]
pub struct DdsSerializedKey(Vec<u8>);

/// This trait indicates whether the associated type is keyed or not, i.e. if the middleware
/// should manage different instances of the type.
pub trait DdsHasKey {
    const HAS_KEY: bool;
}

/// This trait describes how the information contained in the data structure can be serialized to a writer.
///
/// The information generated by method of this trait is typically visible on the
/// `serializedData` element of the Data submessage when transmitting information about
/// a published sample.
pub trait DdsSerializeData {
    fn serialize_data(&self) -> DdsResult<DdsSerializedData>;
}

/// This trait describes how the bytes can be deserialize to construct the data structure.
///
/// This trait is typically used when reading the data from the samples from the DataReader.
/// The `'de` lifetime of this trait is the lifetime of data that may be borrowed from the input when deserializing.
pub trait DdsDeserialize<'de>: Sized {
    fn deserialize_data(serialized_data: &mut &'de [u8]) -> DdsResult<Self>;
}

/// This trait describes how the key information in the data structure can be serialized to a writer.
///
/// The information created by this trait is typically visible on the `serializedData` element
/// of the Data submessage when transmitting information about a disposed or unregistered sample.
pub trait DdsSerializeKeyFields {
    fn serialize_key_fields(&self, writer: impl std::io::Write) -> DdsResult<()>;
}

/// This trait defines how the unique key information can be generated from a given instance of a type.
///
/// The key generated by this trait is not visible externally but it is typically used on the
/// writer side to identify the sample which is being modified at a given moment.
pub trait DdsGetKeyFromFoo {
    fn get_key_from_foo(&self) -> DdsResult<DdsSerializedKey>;
}

/// This trait defines how the unique key information can be generated from the serialized data of a type.
///
/// The key generated by this trait is not visible externally but it is typically used on the
/// reader side to identify the instance of a sample which is being updated by the received Data submessage.
pub trait DdsGetKeyFromSerializedData {
    fn get_key_from_serialized_data(serialized_data: &[u8]) -> DdsResult<DdsSerializedKey>;
}

/// This trait defines how the unique key information can be generated from the serialized key of a type.
///
/// The key generated by this trait is not visible externally but it is typically used on the
/// reader side to identify the instance of a sample which is being unregistered or disposed by the received Data submessage.
pub trait DdsGetKeyFromSerializedKeyFields {
    fn get_key_from_serialized_key_fields(
        serialized_key_fields: &[u8],
    ) -> DdsResult<DdsSerializedKey>;
}

/// Enumeration of the different representations defined by the RTPS standard and supported by DustDDS.
pub enum RtpsRepresentation {
    CdrLe,
    CdrBe,
    PlCdrBe,
    PlCdrLe,
}

type RepresentationIdentifier = [u8; 2];
type RepresentationOptions = [u8; 2];

const CDR_BE: RepresentationIdentifier = [0x00, 0x00];
const CDR_LE: RepresentationIdentifier = [0x00, 0x01];
const PL_CDR_BE: RepresentationIdentifier = [0x00, 0x02];
const PL_CDR_LE: RepresentationIdentifier = [0x00, 0x03];
const REPRESENTATION_OPTIONS: RepresentationOptions = [0x00, 0x00];

/// This trait defines the representation to be used by the type when serializing and deserializing.
///
/// When used in combination with [`serde::Serialize`] and [`serde::Deserialize`] a blanket implementation
/// for the [`DdsSerializeData`] and [`DdsDeserialize`] traits is provided that uses the Cdr serializer and
/// is conformant with the CDR format as specified in the RTPS standard.
pub trait DdsRepresentation {
    const REPRESENTATION: RtpsRepresentation;
}

impl<T> DdsSerializeData for T
where
    T: serde::Serialize + DdsRepresentation,
{
    fn serialize_data(&self) -> DdsResult<DdsSerializedData> {
        let mut writer = Vec::new();
        match T::REPRESENTATION {
            RtpsRepresentation::CdrLe => {
                writer
                    .write_all(&CDR_LE)
                    .map_err(|err| PreconditionNotMet(err.to_string()))?;
                writer
                    .write_all(&REPRESENTATION_OPTIONS)
                    .map_err(|err| PreconditionNotMet(err.to_string()))?;
                let mut serializer =
                    cdr::ser::Serializer::<_, byteorder::LittleEndian>::new(&mut writer);
                serde::Serialize::serialize(self, &mut serializer)
                    .map_err(|err| PreconditionNotMet(err.to_string()))?;
            }
            RtpsRepresentation::CdrBe => {
                writer
                    .write_all(&CDR_BE)
                    .map_err(|err| PreconditionNotMet(err.to_string()))?;
                writer
                    .write_all(&REPRESENTATION_OPTIONS)
                    .map_err(|err| PreconditionNotMet(err.to_string()))?;
                let mut serializer =
                    cdr::ser::Serializer::<_, byteorder::BigEndian>::new(&mut writer);
                serde::Serialize::serialize(self, &mut serializer)
                    .map_err(|err| PreconditionNotMet(err.to_string()))?;
            }
            RtpsRepresentation::PlCdrBe => {
                writer
                    .write_all(&PL_CDR_BE)
                    .map_err(|err| PreconditionNotMet(err.to_string()))?;
                writer
                    .write_all(&REPRESENTATION_OPTIONS)
                    .map_err(|err| PreconditionNotMet(err.to_string()))?;
                let mut serializer =
                    ParameterListSerializer::<_, byteorder::BigEndian>::new(&mut writer);
                serde::Serialize::serialize(self, &mut serializer)
                    .map_err(|err| PreconditionNotMet(err.to_string()))?;
            }
            RtpsRepresentation::PlCdrLe => {
                writer
                    .write_all(&PL_CDR_LE)
                    .map_err(|err| PreconditionNotMet(err.to_string()))?;
                writer
                    .write_all(&REPRESENTATION_OPTIONS)
                    .map_err(|err| PreconditionNotMet(err.to_string()))?;
                let mut serializer =
                    ParameterListSerializer::<_, byteorder::LittleEndian>::new(&mut writer);
                serde::Serialize::serialize(self, &mut serializer)
                    .map_err(|err| PreconditionNotMet(err.to_string()))?;
            }
        };
        Ok(writer.into())
    }
}

impl<'de, T> DdsDeserialize<'de> for T
where
    T: DdsRepresentation + serde::Deserialize<'de>,
{
    fn deserialize_data(serialized_data: &mut &'de [u8]) -> DdsResult<Self> {
        let mut representation_identifier = [0u8, 0];
        serialized_data
            .read_exact(&mut representation_identifier)
            .map_err(|err| PreconditionNotMet(err.to_string()))?;

        let mut representation_option = [0u8, 0];
        serialized_data
            .read_exact(&mut representation_option)
            .map_err(|err| PreconditionNotMet(err.to_string()))?;

        match representation_identifier {
            CDR_BE => {
                let mut deserializer = cdr::Deserializer::<_, _, byteorder::BigEndian>::new(
                    serialized_data,
                    cdr::Infinite,
                );
                serde::Deserialize::deserialize(&mut deserializer)
                    .map_err(|err| PreconditionNotMet(err.to_string()))
            }
            CDR_LE => {
                let mut deserializer = cdr::Deserializer::<_, _, byteorder::LittleEndian>::new(
                    serialized_data,
                    cdr::Infinite,
                );
                serde::Deserialize::deserialize(&mut deserializer)
                    .map_err(|err| PreconditionNotMet(err.to_string()))
            }
            PL_CDR_BE => {
                let mut deserializer =
                    ParameterListDeserializer::<byteorder::BigEndian>::new(serialized_data);
                serde::Deserialize::deserialize(&mut deserializer)
                    .map_err(|err| PreconditionNotMet(err.to_string()))
            }
            PL_CDR_LE => {
                let mut deserializer =
                    ParameterListDeserializer::<byteorder::LittleEndian>::new(serialized_data);
                serde::Deserialize::deserialize(&mut deserializer)
                    .map_err(|err| PreconditionNotMet(err.to_string()))
            }
            _ => Err(PreconditionNotMet(
                "Illegal representation identifier".to_string(),
            )),
        }
    }
}

/// This trait defines the borrowed key holder struct which represents the key associated with type.
///
/// The key holder struct generated in this trait is typically used in cases where an intermediate representation
/// of the key is needed to create for example a serialized key.
///
/// To identify different instances of a type a key is used. This trait allows defining a key holder struct
/// that can be related the underlying DdsType. For example, this type derivation:
/// ```rust
///     use dust_dds::topic_definition::type_support::DdsType;
///
///     #[derive(serde::Serialize, serde::Deserialize, DdsType)]
///     struct KeyedData {
///         #[key]
///         id: u8,
///         value: u32,
///     }
/// ```
/// could result in the following borrowed key holder struct (note that this is meant as an example and the
/// actual type generated by the derive could differ):
/// ```rust
///     struct BorrowedKeyHolder<'a> {
///         id: &'a u8
///     }
/// ```
///
pub trait DdsBorrowKeyHolder {
    // Serde trait bounds placed here since there is no easy way to express this bound
    // without specifying the lifetime 'a which makes the bounds on usage very complicated
    type BorrowedKeyHolder<'a>: serde::Serialize
    where
        Self: 'a;

    fn get_key(&self) -> Self::BorrowedKeyHolder<'_>;
}

/// This trait defines the owning key holder struct which represents the key associated with type.
///
/// The key holder struct generated in this trait is typically used in cases where an intermediate representation
/// of the key is needed and the fields can not be borrowed such as when computing a key from the serialized data.
///
/// To identify different instances of a type a key is used. This trait allows defining a key holder struct
/// that can be related the underlying DdsType. For example, this type derivation:
/// ```rust
///     use dust_dds::topic_definition::type_support::DdsType;
///
///     #[derive(serde::Serialize, serde::Deserialize, DdsType)]
///     struct KeyedData {
///         #[key]
///         id: u8,
///         value: u32,
///     }
/// ```
/// could result in the following owning key holder struct (note that this is meant as an example and the
/// actual type generated by the derive could differ):
/// ```rust
///     struct OwningKeyHolder {
///         id: u8
///     }
/// ```
pub trait DdsOwningKeyHolder {
    type OwningKeyHolder: ?Sized;
}

impl<T> DdsSerializeKeyFields for T
where
    T: DdsBorrowKeyHolder,
{
    fn serialize_key_fields(&self, mut writer: impl std::io::Write) -> DdsResult<()> {
        writer
            .write_all(&CDR_LE)
            .map_err(|err| PreconditionNotMet(err.to_string()))?;
        writer
            .write_all(&REPRESENTATION_OPTIONS)
            .map_err(|err| PreconditionNotMet(err.to_string()))?;
        let mut serializer = cdr::ser::Serializer::<_, byteorder::LittleEndian>::new(writer);
        let key = self.get_key();
        serde::Serialize::serialize(&key, &mut serializer)
            .map_err(|err| PreconditionNotMet(err.to_string()))?;
        Ok(())
    }
}

impl<T> DdsGetKeyFromFoo for T
where
    T: DdsBorrowKeyHolder,
{
    fn get_key_from_foo(&self) -> DdsResult<DdsSerializedKey> {
        let mut writer = Vec::new();
        let mut serializer = cdr::ser::Serializer::<_, byteorder::BigEndian>::new(&mut writer);
        let key = self.get_key();
        serde::Serialize::serialize(&key, &mut serializer)
            .map_err(|err| PreconditionNotMet(err.to_string()))?;
        Ok(writer.into())
    }
}

impl<T> DdsGetKeyFromSerializedData for T
where
    T: DdsOwningKeyHolder + DdsRepresentation,
    T::OwningKeyHolder: for<'de> serde::Deserialize<'de> + serde::Serialize,
{
    fn get_key_from_serialized_data(mut serialized_data: &[u8]) -> DdsResult<DdsSerializedKey> {
        let serialized_data = &mut serialized_data;
        let mut representation_identifier = [0u8, 0];
        serialized_data
            .read_exact(&mut representation_identifier)
            .map_err(|err| PreconditionNotMet(err.to_string()))?;

        let mut representation_option = [0u8, 0];
        serialized_data
            .read_exact(&mut representation_option)
            .map_err(|err| PreconditionNotMet(err.to_string()))?;

        let key_holder: T::OwningKeyHolder = match representation_identifier {
            CDR_BE => {
                let mut deserializer = cdr::Deserializer::<_, _, byteorder::BigEndian>::new(
                    serialized_data,
                    cdr::Infinite,
                );
                serde::Deserialize::deserialize(&mut deserializer)
                    .map_err(|err| PreconditionNotMet(err.to_string()))
            }
            CDR_LE => {
                let mut deserializer = cdr::Deserializer::<_, _, byteorder::LittleEndian>::new(
                    serialized_data,
                    cdr::Infinite,
                );
                serde::Deserialize::deserialize(&mut deserializer)
                    .map_err(|err| PreconditionNotMet(err.to_string()))
            }
            PL_CDR_BE => {
                let mut deserializer =
                    ParameterListDeserializer::<byteorder::BigEndian>::new(serialized_data);
                serde::Deserialize::deserialize(&mut deserializer)
                    .map_err(|err| PreconditionNotMet(err.to_string()))
            }
            PL_CDR_LE => {
                let mut deserializer =
                    ParameterListDeserializer::<byteorder::LittleEndian>::new(serialized_data);
                serde::Deserialize::deserialize(&mut deserializer)
                    .map_err(|err| PreconditionNotMet(err.to_string()))
            }
            _ => Err(PreconditionNotMet(
                "Illegal representation identifier".to_string(),
            )),
        }?;

        let mut writer = Vec::new();
        let mut serializer = cdr::ser::Serializer::<_, byteorder::BigEndian>::new(&mut writer);
        serde::Serialize::serialize(&key_holder, &mut serializer)
            .map_err(|err| PreconditionNotMet(err.to_string()))?;
        Ok(writer.into())
    }
}

macro_rules! implement_dds_get_key_for_built_in_type {
    ($t:ty) => {
        impl DdsBorrowKeyHolder for $t {
            type BorrowedKeyHolder<'a> = $t;

            fn get_key(&self) -> Self::BorrowedKeyHolder<'_> {
                *self
            }
        }

        impl DdsOwningKeyHolder for $t {
            type OwningKeyHolder = $t;
        }
    };
}

implement_dds_get_key_for_built_in_type!(bool);
implement_dds_get_key_for_built_in_type!(char);
implement_dds_get_key_for_built_in_type!(u8);
implement_dds_get_key_for_built_in_type!(i8);
implement_dds_get_key_for_built_in_type!(u16);
implement_dds_get_key_for_built_in_type!(i16);
implement_dds_get_key_for_built_in_type!(u32);
implement_dds_get_key_for_built_in_type!(i32);
implement_dds_get_key_for_built_in_type!(u64);
implement_dds_get_key_for_built_in_type!(i64);
implement_dds_get_key_for_built_in_type!(usize);
implement_dds_get_key_for_built_in_type!(isize);
implement_dds_get_key_for_built_in_type!(f32);
implement_dds_get_key_for_built_in_type!(f64);

impl<T> DdsBorrowKeyHolder for Vec<T>
where
    T: serde::Serialize + for<'de> serde::Deserialize<'de>,
{
    type BorrowedKeyHolder<'a> = &'a Vec<T> where T:'a;

    fn get_key(&self) -> Self::BorrowedKeyHolder<'_> {
        self
    }
}

impl<T> DdsOwningKeyHolder for Vec<T>
where
    T: serde::Serialize + for<'de> serde::Deserialize<'de>,
{
    type OwningKeyHolder = Vec<T>;
}

impl DdsBorrowKeyHolder for String {
    type BorrowedKeyHolder<'a> = &'a str;

    fn get_key(&self) -> Self::BorrowedKeyHolder<'_> {
        self
    }
}

impl DdsOwningKeyHolder for String {
    type OwningKeyHolder = String;
}

impl<const N: usize, T> DdsBorrowKeyHolder for [T; N]
where
    [T; N]: serde::Serialize + for<'de> serde::Deserialize<'de>,
{
    type BorrowedKeyHolder<'a> = &'a [T; N] where T:'a;

    fn get_key(&self) -> Self::BorrowedKeyHolder<'_> {
        self
    }
}

impl<const N: usize, T> DdsOwningKeyHolder for [T; N]
where
    [T; N]: serde::Serialize + for<'de> serde::Deserialize<'de>,
{
    type OwningKeyHolder = [T; N];
}

impl<'a, T> DdsOwningKeyHolder for &'a T
where
    T: ?Sized,
{
    type OwningKeyHolder = T;
}

/// This trait represent the group of traits that can be automatically derived when a type is to be transmitted using the format
/// defined by RTPS to ensure interoperability between different implementations.
///
/// This is only a convinience trait to allow easily deriving the different traits. If the individual
/// traits are manually implemented then this trait does not have to be implemented.
///
/// # Derivable
/// This trait can be automatically derived. The generated trait uses by default a CdrLe
/// representation and it determines whether the type is keyed or not depending on whether
/// any field is marked `#[key]` or not.
///
/// An example of a typical usage of derive is the following:
///
/// ```rust
///     use dust_dds::topic_definition::type_support::DdsType;
///
///     #[derive(serde::Serialize, serde::Deserialize, DdsType)]
///     struct KeyedData {
///         #[key]
///         id: u8,
///         value: u32,
///     }
/// ```
///
/// It is also possible to derive structs with a lifetime:
///
/// ```rust
///     use dust_dds::topic_definition::type_support::DdsType;
///     use std::borrow::Cow;
///
///     #[derive(serde::Serialize, serde::Deserialize, DdsType)]
///     struct BorrowedData<'a> {
///         #[key]
///         id: u8,
///         #[serde(borrow)]
///         value: Cow<'a, [u8]>,
///     }
/// ```
///
pub trait DdsType: DdsRepresentation + DdsHasKey + DdsBorrowKeyHolder + DdsOwningKeyHolder {}
