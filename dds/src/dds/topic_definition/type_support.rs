//! The traits necessary to make a type capable of being published and subscribed by the DDS middleware.
//!
//! To be able to publish and subscribe the information contained in a type using DustDDS,
//! this type has to implement the following traits [`DdsHasKey`], [`CdrSerialize`], [`DdsDeserialize`],
//! [`DdsSerializeKey`], [`DdsGetKeyFromFoo`], [`DdsGetKeyFromSerializedData`] and
//! [`DdsGetKeyFromSerializedKeyFields`]. Depending on the used functionality only a subset
//! of these traits might need to be implemented.
//!
//! While implementing the traits above is the most flexible way to have a type supported by
//! DustDDS it is the most common use case that a type must be transmitted using the format
//! defined by RTPS to ensure interoperability between different implementations.
//! For this common scenario DustDDS provides a set of traits which are simpler to implement
//! and which provide blanket implementations for the traits above. These are
//! [`DdsBorrowKeyHolder`] and [`DdsOwningKeyHolder`] in combination with
//! [`serde::Serialize`] and [`serde::Deserialize`].
//!
//! For the large majority of cases the simpler subset of traits can be automatically derived
//! using the provided procedural macro [`DdsType`]. Each of these traits can also be individually
//! derived using the respective proc macro.
//!

use std::io::{Read, Write};

use crate::{
    cdr::{
        deserialize::CdrDeserialize, deserializer::CdrDeserializer, endianness::CdrEndianness,
        parameter_list_deserialize::ParameterListDeserialize,
        parameter_list_deserializer::ParameterListDeserializer,
        parameter_list_serialize::ParameterListSerialize,
        parameter_list_serializer::ParameterListSerializer, serialize::CdrSerialize,
        serializer::CdrSerializer,
    },
    implementation::data_representation_builtin_endpoints::parameter_id_values::PID_SENTINEL,
    infrastructure::{
        error::{DdsError, DdsResult},
        instance::InstanceHandle,
    },
};

pub use dust_dds_derive::{
    DdsDeserialize, DdsHasKey, DdsInstanceHandle, DdsInstanceHandleFromSerializedData,
    DdsSerialize, DdsSerializeKey, DdsType,
};

/// The [`DdsSerializedKey`] represents the key associated with a specific instance of
/// a type that can be published and subscribed over DDS.
#[derive(
    Debug,
    PartialEq,
    Clone,
    Eq,
    derive_more::Constructor,
    derive_more::From,
    derive_more::Into,
    derive_more::AsRef,
)]
pub struct DdsSerializedKey(Vec<u8>);

/// This trait indicates whether the associated type is keyed or not, i.e. if the middleware
/// should manage different instances of the type.
pub trait DdsHasKey {
    const HAS_KEY: bool;
}

/// This trait defines how to serialize the information contained in a data structure to be published.
///
/// The information generated by the method of this trait is typically visible on the
/// `serializedData` element of the Data submessage when transmitting a published sample.
pub trait DdsSerialize {
    fn serialize_data(&self, writer: &mut Vec<u8>) -> DdsResult<()>;
}

/// This trait describes how the bytes can be deserialize to construct the data structure.
///
/// This trait is typically used when reading the data from the samples from the DataReader.
/// The `'de` lifetime of this trait is the lifetime of data that may be borrowed from the input when deserializing.
pub trait DdsDeserialize<'de>: Sized {
    fn deserialize_data(serialized_data: &'de [u8]) -> DdsResult<Self>;
}

/// This trait describes how the key information in the data structure can be serialized to a writer.
///
/// The information created by this trait is typically visible on the `serializedData` element
/// of the Data submessage when transmitting information about a disposed or unregistered sample.
pub trait DdsSerializeKey {
    fn serialize_key(&self, writer: &mut Vec<u8>) -> DdsResult<()>;
}

/// This trait defines how the unique instance handle can be generated from a given instance of a type.
///
/// The handle generated by this trait is not visible externally but it is typically used on the
/// writer side to identify the sample which is being modified at a given moment.
pub trait DdsInstanceHandle {
    fn get_instance_handle(&self) -> DdsResult<InstanceHandle>;
}

/// This trait defines how the unique key information can be generated from the serialized data of a type.
///
/// The key generated by this trait is not visible externally but it is typically used on the
/// reader side to identify the instance of a sample which is being updated by the received Data submessage.
pub trait DdsInstanceHandleFromSerializedData {
    fn get_handle_from_serialized_data(serialized_data: &[u8]) -> DdsResult<InstanceHandle>;
}

/// This trait defines how the unique key information can be generated from the serialized key of a type.
///
/// The key generated by this trait is not visible externally but it is typically used on the
/// reader side to identify the instance of a sample which is being unregistered or disposed by the received Data submessage.
pub trait DdsGetKeyFromSerializedKeyFields {
    fn get_key_from_serialized_key_fields(
        serialized_key_fields: &[u8],
    ) -> DdsResult<DdsSerializedKey>;
}

/// This trait represent the group of traits that can be automatically derived when a type is to be transmitted using the format
/// defined by RTPS to ensure interoperability between different implementations.
///
/// This is only a convinience trait to allow easily deriving the different traits. If the individual
/// traits are manually implemented then this trait does not have to be implemented.
///
/// # Derivable
/// This trait can be automatically derived. The generated trait uses by default a CdrLe
/// representation and it determines whether the type is keyed or not depending on whether
/// any field is marked `#[dust_dds(key)]` or not.
///
/// An example of a typical usage of derive is the following:
///
/// ```rust
///     use dust_dds::topic_definition::type_support::DdsType;
///
///     #[derive(DdsType)]
///     struct KeyedData {
///         #[dust_dds(key)]
///         id: u8,
///         value: u32,
///     }
/// ```
///
/// It is also possible to derive structs with a lifetime:
///
/// ```rust
///     use dust_dds::topic_definition::type_support::DdsType;
///     use std::borrow::Cow;
///
///     #[derive(DdsType)]
///     struct BorrowedData<'a> {
///         #[dust_dds(key)]
///         id: u8,
///         value: Cow<'a, [u8]>,
///     }
/// ```
///
pub trait DdsType {}

type RepresentationIdentifier = [u8; 2];
type RepresentationOptions = [u8; 2];

const CDR_BE: RepresentationIdentifier = [0x00, 0x00];
const CDR_LE: RepresentationIdentifier = [0x00, 0x01];
const PL_CDR_BE: RepresentationIdentifier = [0x00, 0x02];
const PL_CDR_LE: RepresentationIdentifier = [0x00, 0x03];
const REPRESENTATION_OPTIONS: RepresentationOptions = [0x00, 0x00];

pub fn serialize_rtps_cdr(
    value: &impl CdrSerialize,
    writer: &mut Vec<u8>,
    endianness: CdrEndianness,
) -> DdsResult<()> {
    match endianness {
        CdrEndianness::LittleEndian => writer.write_all(&CDR_LE)?,
        CdrEndianness::BigEndian => writer.write_all(&CDR_BE)?,
    }
    writer.write_all(&REPRESENTATION_OPTIONS)?;
    let mut serializer = CdrSerializer::new(writer, endianness);
    CdrSerialize::serialize(value, &mut serializer)?;
    Ok(())
}

pub fn serialize_rtps_cdr_pl(
    value: &impl ParameterListSerialize,
    writer: &mut Vec<u8>,
    endianness: CdrEndianness,
) -> DdsResult<()> {
    match endianness {
        CdrEndianness::LittleEndian => writer.write_all(&PL_CDR_LE)?,
        CdrEndianness::BigEndian => writer.write_all(&PL_CDR_BE)?,
    }
    writer.write_all(&REPRESENTATION_OPTIONS)?;
    let mut serializer = ParameterListSerializer::new(writer, endianness);
    ParameterListSerialize::serialize(value, &mut serializer)?;
    serializer.write(PID_SENTINEL, &())?;
    Ok(())
}

pub fn deserialize_rtps<'de, T>(serialized_data: &mut &'de [u8]) -> DdsResult<T>
where
    T: CdrDeserialize<'de> + ParameterListDeserialize<'de>,
{
    let mut representation_identifier = [0u8, 0];
    serialized_data
        .read_exact(&mut representation_identifier)
        .map_err(|err| DdsError::Error(err.to_string()))?;

    let mut representation_option = [0u8, 0];
    serialized_data
        .read_exact(&mut representation_option)
        .map_err(|err| DdsError::Error(err.to_string()))?;

    let value = match representation_identifier {
        CDR_BE => {
            let mut deserializer = CdrDeserializer::new(serialized_data, CdrEndianness::BigEndian);
            Ok(CdrDeserialize::deserialize(&mut deserializer)?)
        }
        CDR_LE => {
            let mut deserializer =
                CdrDeserializer::new(serialized_data, CdrEndianness::LittleEndian);
            Ok(CdrDeserialize::deserialize(&mut deserializer)?)
        }
        PL_CDR_BE => {
            let mut deserializer =
                ParameterListDeserializer::new(serialized_data, CdrEndianness::BigEndian);
            Ok(ParameterListDeserialize::deserialize(&mut deserializer)?)
        }
        PL_CDR_LE => {
            let mut deserializer =
                ParameterListDeserializer::new(serialized_data, CdrEndianness::LittleEndian);
            Ok(ParameterListDeserialize::deserialize(&mut deserializer)?)
        }
        _ => Err(DdsError::Error(
            "Unknownn representation identifier".to_string(),
        )),
    }?;
    Ok(value)
}

pub fn deserialize_rtps_cdr<'de, T>(serialized_data: &mut &'de [u8]) -> DdsResult<T>
where
    T: CdrDeserialize<'de>,
{
    let mut representation_identifier = [0u8, 0];
    serialized_data
        .read_exact(&mut representation_identifier)
        .map_err(|err| DdsError::Error(err.to_string()))?;

    let mut representation_option = [0u8, 0];
    serialized_data
        .read_exact(&mut representation_option)
        .map_err(|err| DdsError::Error(err.to_string()))?;

    let mut deserializer = match representation_identifier {
        CDR_BE => Ok(CdrDeserializer::new(
            serialized_data,
            CdrEndianness::BigEndian,
        )),
        CDR_LE => Ok(CdrDeserializer::new(
            serialized_data,
            CdrEndianness::LittleEndian,
        )),
        _ => Err(DdsError::Error(
            "Unknownn representation identifier".to_string(),
        )),
    }?;
    let value = CdrDeserialize::deserialize(&mut deserializer)?;
    Ok(value)
}

pub fn deserialize_rtps_cdr_pl<'de, T>(serialized_data: &mut &'de [u8]) -> DdsResult<T>
where
    T: ParameterListDeserialize<'de>,
{
    let mut representation_identifier = [0u8, 0];
    serialized_data
        .read_exact(&mut representation_identifier)
        .map_err(|err| DdsError::Error(err.to_string()))?;

    let mut representation_option = [0u8, 0];
    serialized_data
        .read_exact(&mut representation_option)
        .map_err(|err| DdsError::Error(err.to_string()))?;

    let mut deserializer = match representation_identifier {
        PL_CDR_BE => Ok(ParameterListDeserializer::new(
            serialized_data,
            CdrEndianness::BigEndian,
        )),
        PL_CDR_LE => Ok(ParameterListDeserializer::new(
            serialized_data,
            CdrEndianness::LittleEndian,
        )),
        _ => Err(DdsError::Error(
            "Unknownn representation identifier".to_string(),
        )),
    }?;
    let value = ParameterListDeserialize::deserialize(&mut deserializer)?;
    Ok(value)
}
